1.메소드란 객체의 동작에 해당하는 중괄호{} 블록
2.메소드의 기능: 필드를 읽고 쓴다./ 다른객체를 생성하여 다양한 기능을 수행한다.
	/객체 간의 데이터 전달의 수단으로 사용한다(외부로부터 매개값을 받고
	실행 후 외부로 리턴값을 전달한다)
	
======================
3.메소드 선언(p214)
---------------------
1)메소드 선언은 선언부(리턴타입, 메소드이름, 매개변수 선언)와 실행블록으로 나뉨
*메소드 선언부를 메소드 시그니처(signiture)라고도 함
(p215~) 수요일, 6월 마지막주 //
2)리턴 타입: 메소드가 실행 후 리턴하는 값의 타입
-메소드마다 있을 수도 있고, 없을 수도 있음
-메소드가 결과를 호출한 곳에 넘겨줄 때는 리턴값이 있어야함
 null,0,false..이것들도 하나의 값으로 취급
 예시실습)void powerOn(){..}:리턴 타입이 없음
 	   double divide(int x, int y){...} :리턴 타입이 있음
 -두가지 경우에서 메소드를 호출방법이 각각 다름
 	예시)powerOn();
 		double result = divide(10,20);
 		----->리턴값을 변수 result에 대입하는데 , 그값이 double로
 		명시되어 있기 때문에  double형 변수 result를 선언한 것이다.
 		만약 int result = divide(10,20);//컴파일 에러
 		또한, 굳이 값을 받을 필요가 없는 경우는 리턴값이 있더라도 그냥 호출만 해 줄수도 있다.
 		divide(10,20);
 3)메소드 이름(식별자: 내가 정해줄 수 있는 이름) 규칙
 -숫자로 시작 X
 -특수 문자 $,_만 허용된다.
 -소문자로 작성
 -혼합단어일 경우는 단어가 시작될 때 그 맨앞글자만 대문자로 구분해 적어준다.
 (-한가지더 너무 짧게 짓지말고, 어떤 기능을 위한 메소드인지 기능 중심으로 작성해준다.)
 예시)void run(){...}
 	void startEngine(){...}
 	String getName(){...}
 	int[] getScores(){...}
 	
 4)매개변수 선언: 메소드가 실행될 때 외부에서 넘겨주는 필요 데이터
 -매개변수가 필요한 경우 vs 매개변수가 필요없는 경우
 예)divide()에서 두수가 필요 vs powerOn()에서는 필요 없음
 - double result = divide(10,20);
   double result = divide(10.5,20.0);<=== 컴파일 에러
   					왜? 두수는 int여야한다고 정의되어있기 때문이다.
   					강제로 다운캐스팅을 할수 없기 때문에 에러가남
   	byte b1 = 10;
   	byte b2 = 20;
   	double result = divide(b1,b2); //정상적으로 컴파일 됨
   				왜? 연산시(매개변수를 대입할때)byte는 int로 바뀌게 됨.
5) 메소드에서 매개 변수의 수를 모를 경우
	방법1: 배열에 넣어서 넘겨준다.
	방법2: 가변인자(...)를 사용한다.
	-방법1 예시
	int sum1(int[] values){...} 라는 메소드가 있으면
	int[] values = {1,2,3};
	int result = sum1(values);//변수에 담아서 보내거나
	int result = sum1(new int[]{1,2,3,4,5});//바로 값으로 보냄
	
	-방법2 예시
	int sum2(int...values){}
	int result = sum2(1,2,3);
	int result = sum2(1,2,3,4,5);-->여기서 values는 배열이라고 간주
	
	실습)p220~221
	
	
===============================
<메소드의 리턴문>에 관하여
------------------------------
1.리턴값이 있는 메소드의 ㅣ경우
1)메소드 선언에 리턴 타입이 있는 메소드는 반드시 리턴문을 사용해서 리턴값을 지정해준다
	예시] return 리턴값;
2) return문의 리턴값은 리턴타입과 동일하거나, 리턴 타입으로 형변환 가능한것이어야한다.
	예시] int plus(int x, int y){
			int result = x+y;
			return result;
			}
			int plut(int x , int y){
			byte result = (byte)(x+y);
			return result; //int타입으로 업캐스팅됨(자동 타입변환)
			}
3)Unreachable code:
2.리턴값이 없는 메소드(void)
1)이때의 리턴문은 메소드를 강제로 종료할때이다.
	예시] return;

===================
<메소드 호출>에 대해여
-------------------
1. 메소드는 클래스 내부 또는 클래스 외부의호출에 의해 실행된다.
	*내부에서 호출할 경우: 메소드명만 불러주면 됨.
	그러나 외부에서 호출할때는 : 객체를 만들고 그 참조변수에서 메소드를 호출해야함
	(매개변수도 입력해주어야함에 주의)
=====================================
<메소드 오버로딩>에 대하여
-------------------------------------
1. 정의:클래스 내에 같은 이름의 메소드를 여러개 선언하는 것을
	메소드오버로딩(overloading)이라고 한다.
	* 오버로딩: 사전적의미는 많이 싣는것.
2. 조건: 매개변수의 타입, 개수, 순서 중 하나는 반드시 달라야한다.
	[예시]
		A :int plus(int x, int y){
			int result = x + y;
			return result;
		}
		B :double plus(double x, double y){
			double result = x + y;
			return result;
		}
		오버로딩된 위의 메소드를 호출할 경우, jvm은
		매개값의 타입을 보고 메소드를 선택함
	1)퀴즈:다음은 어떤 메소드를 호출하는가?
	 plus(10,20);A
	 
	 plus(10.5,20.3);B
	 
	 int x=10;
	 double y=20.3;
	 plus(x,y);B
   				
 3.메소드 오버로딩에 해당되지 않는 경우
 - 매개변수 이름만 바꾸는 경우
 	예) int divide(int x,int y){...}
 		double divide(int boonja, int boonmo){..}
 -리턴 타입은 오버로딩에서 관계되지 않는다.
 	위의 예에서 int, double이 다르지만 영향을 주지 않아 같은 메소드로 취급됨. 				
   				
   				
   				
   				
   				
   				
   				
  